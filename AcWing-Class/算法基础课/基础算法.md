# 基础算法

## 1.快速排序

- #### 算法思想：`分治法`

##### 写法一：

```c++
void quickSort(vector<int> &arr, int L, int R){
  //base case
  if (L >= R) return;//只有一个数,边界检测，很重要
  //定义左右边界
  int less = L - 1, more = R + 1;
  //定义比较的标准，取中间的数作为比较标准
  int target = arr[L+(R - L >> 1)];
  //遍历数组，把小于target的数放左边，大于target的数放右边
  while (less < more) {
    do ++less; while(arr[less] < target);//从左往右找到第一个大于等于target的数的下标
    do --more; while(arr[more] > target);//从右往左找到第一个小于等于target的数的下标
    if (less < more) swap(arr[less], arr[more]);
    //什么时候不满足条件？-->当找到了target在数组中的正确位置，此时less > more
  }
  //递归去，分别快排左边和右边子数组
  quickSort(arr, L, more);
  quickSort(arr, more+1, R);
}
```

##### 写法二：

```c++
vector<int> partition(vector<int> &arr, int L, int R){
  int less = L - 1, more = R;
  //less表示最后一个小于arr[R]的下标,more表示第一个大于arr[R]的下标
  while (L < more) {
    if (arr[L] < arr[R]) {
      swap(arr[++less], arr[L++]);
    }else if (arr[L] > arr[R]) {
      swap(arr[--more], arr[L]);
    }else {
      L++;
    }
  }
  swap(arr[more], arr[R]);
  return vector<int> {less + 1, more};
}

void quickSort(vector<int> &arr, int L, int R){
  if (L < R) {
    //swap(arr[L+(int)(random()*(R - L + 1))], arr[R]);//快排3.0
    vector<int> p = partition(arr, L, R);
    quickSort(arr, L, p[0] - 1);
    quickSort(arr, p[1] + 1, R);
  }
}
```

## 2.归并排序

- #### 算法思想：`分治法`

  ##### 写法一：

```c++
const int N = 1000010;
void mergeSort(vector<int> &arr, int L, int R){
  //递归出口
  if (L >= R) return;
  //找分界点，划分大问题
  int mid = (L + R) >> 1;
  //划分子问题，“分”-递归调用
  mergeSort(arr, L, mid);
  mergeSort(arr, mid + 1, R);
  //合并子问题
  //思路：谁小就复制谁
  int k = 0, i = L, j = mid + 1;
  vector<int> tmp(N, 0);
  while (i <= mid && j <= R) {
    if (arr[i] <= arr[j]) tmp[k++] = arr[i++];
    else tmp[k++] = arr[j++];
  }
  //剩余的情况
  while (i <= mid) tmp[k++] = arr[i++];
  while (j <= R) tmp[k++] = arr[j++];
  //拷贝回原来的数组
  for (int i = L, j = 0; i <= R; i++, j++) arr[i++] = tmp[j++];    
}
```

##### 写法二：

```c++
void mergeSort(vector<int> &arr){
  //边界
  if (arr.size() < 2) return;
  else mergeSort(arr, 0, arr.size() - 1);
}

void mergeSort(vector<int> &arr, int L, int R){
  if (L == R) return;
  else {
    //分界点
    int mid = L + (R - L) >> 1;
    mergeSort(arr, L, mid);
    mergeSort(arr, mid + 1, R);
    //合并
    merge(arr, L, mid, R);
  }
}

void merge(vector<int> &arr, int L, int M, int R){
  //int* help = new int[R - L + 1];
  vector<int> help(R - L + 1, 0);
  int i = 0, p1 = L, p2 = M + 1;
  while (p1 <= M && p2 <= R) {
    help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++]; 
  }
  //剩余情况
  while (p1 <= M) help[i++] = arr[p1++];
  while (p2 <= R) help[i++] = arr[p2++];
  //拷贝回原来的数组
  for (int i = 0; i < help.size(); i++)  arr[L+i] = help[i];
  //delete [] help;
}
```

## 3.二分法

- #### 算法思想：`二分的本质是二段性不是单调性`（并不是只有满足了单调性才能使用二分法，只要能通过某种标准将区域一分为二就可以使用二分法）

  ###### 例题：给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。如果数组中不存在该元素，则返回“-1 -1”。

  ###### 输入格式：第一行包含整数n和q，表示数组长度和询问个数。第二行包含n个整数（均在1~10000范围内），表示完整数组。接下来q行，每行包含一个整数k，表示一个询问元素。

  ###### 	如果数组中不存在该元素，则返回“-1 -1”。

  ###### 	数据范围

  ###### 	1≤n≤100000

  ###### 	1≤q≤10000

  ###### 	1≤k≤10000


```markdown
输入:
6 3
1 2 2 3 3 4
3
4
5

输出:
3 4
5 5
-1 -1
```

###### 题解：

```c++
#include <iostream>
#include <vector>

using namespace std;

int main(){
  int n, q;
  cin>>n>>q;
  
  vector<int> arr(n, 0);
  for (int i = 0; i < n; i++) cin>>arr[i];
  
  while (q--){
    int x;
    cin>>x;
    
    int l = 0, r = n - 1;
    while (l < r) {//找（左边界）第一个大于等于x的数
      int mid = (l + r) >> 1;
      if (x <= arr[mid]) r = mid;
      else l = mid + 1;
    }
    if (arr[l] != x) cout << "-1 -1" << endl;
    else {
      cout<<l<<" ";
      int l = 0, r = n - 1;
      while (l < r) {//找（右边界）第一个小于等于x的数
        int mid = (l + r + 1) >> 1;//??为啥要加一
        if (x >= arr[mid]) l = mid;
        else r = mid - 1;
      }
      cout<<l<<endl;
    }
  }
  return 0;
}
```

- #### 边界问题：

  ##### 解释的比较好博客：

  ##### 1.[不需要考虑mid+1、mid-1的二分查找模板，希望大家都能学会](https://blog.csdn.net/WJPnb1/article/details/126360962?spm=1001.2014.3001.5502)

  ##### 2.[二分查找 & 二分答案 万字详解，超多例题，带你学透二分](https://blog.csdn.net/Mr_dimple/article/details/114656142?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-8-114656142-blog-126360962.pc_relevant_multi_platform_featuressortv2dupreplace&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-8-114656142-blog-126360962.pc_relevant_multi_platform_featuressortv2dupreplace&utm_relevant_index=9)

  ##### 总结：

  1. 先写一个check函数；
  2. 判定在check的情况下（true和false的情况下），如何更新区间。
  3. 在check(m)==true的分支下是：
  	1. `l=mid`的情况，中间点的更新方式是`m=(l+r+1)>>1`
  	2. `r=mid`的情况，中间点的更新方式是`m=(l+r)>>1`

  

## 3.高精度

- #### 问题描述：

	#### 模拟cpp中高精度数的加减乘除。

	1. ##### 高精度加法：


```c++
  #include <iostream>
  #include <vector>
  #include <string>
  
  
  using namespace std;
  
  vector<int> add(vector<int> &A, vector<int> &B){
       if (A.size() < B.size()) return add(B, A);//为了方便计算，让A中保存较长的数字， B中保存较短的数字
       vector<int> C;//保存结果的数组
       int carry = 0;//进位，开始时是0
       for (int i = 0; i < A.size(); i++) {
            carry += i < B.size() ? A[i] + B[i] : A[i];
            C.push_back(carry%10);
            carry /= 10;//更新进位
       }
       if (carry) C.push_back(carry);
       return C;
  }
  
  int main(){
       string a, b;//字符串储存高精度数
       vector<int> A, B;
       cin>>a>>b;
       //将数储存到vector中(逆序储存！！！)
       for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
       for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
       vector<int> C = add(A, B);
       for (int i = C.size() - 1; i >= 0; i-- ) cout << C[i];//倒序输出C中的数字
       cout << endl;
       return 0;
  }
```

2. ##### 高精度减法：

```c++
#include <iostream>
#include <vector>

using namespace std;

//高精度减法的问题 1.负数 2.借位
bool cmp(vector<int> &A, vector<int> &B){
     if (A.size() != B.size()) return A.size() > B.size();
     else {
          for (int i = A.size() - 1; i >= 0; i--) {
               if (A[i] != B[i]) return A[i] > B[i];
          }
     }
     return true;
}

vector<int> sub(vector<int> &A, vector<int> &B){
     //此时A>B一定成立
     vector<int> C;//save the ans
     int carry = 0;
     for (int i = 0; i < A.size(); i++) {
          carry = A[i] - carry;
          if(i < B.size()) carry -= B[i];//t有可能小于0
          C.push_back((carry + 10) % 10 ); // 合而为1
          if (carry < 0) carry = 1;//借位了
          else carry = 0;
     }
     while(C.size() > 1 && C.back() == 0) C.pop_back();  //去掉前导0
     return C;
}

int main(){
    string a ,b;
    vector<int> A, B;

    cin >> a >> b ;
    for(int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    for(int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');

    if (cmp(A,B)) {//A >= B
        auto C = sub(A, B);
        for(int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
        return 0;
    }
    else {//A < B
        auto C = sub(B, A);
        printf("-");
        for(int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
        return 0;
    }


}
```

2. ##### 高精度乘法：

- ##### 高精度 X 低精度

```c++
#include <iostream>
#include <vector>

using namespace std;

vector <int> mul(vector <int> & A, int b) {
     //
     vector <int> C;
     int carry = 0;
     for (int i = 0; i < A.size(); i++) {
          carry += A[i] * b;//t + A[i] * b = 7218
          C.push_back(carry%10);//只取个位 8
          carry /= 10;//721 看作进位
     }
     while (carry) {// 处理最后剩余的 t
        C.push_back(carry % 10);
        carry /= 10;
     }
     while (C.size() > 1 && C.back() == 0) C.pop_back();
     return C;
}

int main() {
    string a;//高精度
    int b;//低精度
    cin >> a >> b;

    vector <int> A;
    for (int i = a.size() - 1; i >= 0; i --) A.push_back(a[i] - '0');

    auto C = mul(A, b);//A > b

    for (int i = C.size() - 1; i >= 0; i --) {
        cout << C[i];
    }
    return 0;
}
```

- **高精度 X 高精度**

```c++
#include <iostream>
#include <vector>

using namespace std;

vector<int> mul(vector<int> &A, vector<int> &B) {
     vector<int> C(A.size() + B.size() + 7, 0);
     for (int i = 0; i < A.size(); i++)
        for (int j = 0; j < B.size(); j++)
            C[i + j] += A[i] * B[j];
    int t = 0;
    for (int i = 0; i < C.size(); i++) { // i = C.size() - 1时 t 一定小于 10
        t += C[i];
        C[i] = t % 10;
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back(); // 必须要去前导 0，因为最高位很可能是 0
    return C;
}

int main() {
    string a, b;
    cin >> a >> b; // a = "1222323", b = "2323423423"

    vector<int> A, B;
    for (int i = a.size() - 1; i >= 0; i--)
        A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i--)
        B.push_back(b[i] - '0');

    auto C = mul(A, B);

    for (int i = C.size() - 1; i >= 0; i--)
        cout << C[i];

    return 0;
}
```

2. ##### 高精度除法：

```c++
#include <iostream>
#include <vector>
#include <algorithm>


using namespace std;

vector<int> div(vector<int> &A,int B,int &r){//r传入r的地址，便于直接对余数r进行修改
     vector<int> C;
     for(int i=0;i<A.size();i++){//对A从最高位开始处理
          r=r*10+A[i];//将上次的余数*10在加上当前位的数字，便是该位需要除的被除数
          C.push_back(r / B);
          r = r % B;
     }
     reverse(C.begin(),C.end());
     while(C.size()>1&&C.back()==0) C.pop_back();
     return C;
}

int main(){
     string a;
     int B,r=0; //代表余数
     cin>>a>>B;
     vector<int> A;
     for(int i=0;i<a.size();i++) A.push_back(a[i]-'0');//注意这次的A是由高为传输至低位，由于在除法的手算过程中，发现从高位进行处理
     //for(int i=0;i<A.size();i++) cout<<A[i];
     //cout<<B;
     auto C = div(A,B,r);
     for(int i=C.size()-1;i>=0;i--) cout<<C[i];//将C从最高位传给最低位
     cout<<endl<<r;//输出余数
     cout<<endl;
     return 0;
}
```

## 4.前缀和与差分

