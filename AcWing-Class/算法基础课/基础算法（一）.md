# 基础算法（一）

## 1.快速排序

- #### 算法思想：==分治法==

##### 写法一：

```c++
void quickSort(vector<int> &arr, int L, int R){
  //base case
  if (L >= R) return;//只有一个数,边界检测，很重要
  //定义左右边界
  int less = L - 1, more = R + 1;
  //定义比较的标准，取中间的数作为比较标准
  int target = arr[L+(R - L >> 1)];
  //遍历数组，把小于target的数放左边，大于target的数放右边
  while (less < more) {
    do ++less; while(arr[less] < target);//从左往右找到第一个大于等于target的数的下标
    do --more; while(arr[more] > target);//从右往左找到第一个小于等于target的数的下标
    if (less < more) swap(arr[less], arr[more]);
    //什么时候不满足条件？-->当找到了target在数组中的正确位置，此时less > more
  }
  //递归去，分别快排左边和右边子数组
  quickSort(arr, L, more);
  quickSort(arr, more+1, R);
}
```

##### 写法二：

```c++
vector<int> partition(vector<int> &arr, int L, int R){
  int less = L - 1, more = R;
  //less表示最后一个小于arr[R]的下标,more表示第一个大于arr[R]的下标
  while (L < more) {
    if (arr[L] < arr[R]) {
      swap(arr[++less], arr[L++]);
    }else if (arr[L] > arr[R]) {
      swap(arr[--more], arr[L]);
    }else {
      L++;
    }
  }
  swap(arr[more], arr[R]);
  return vector<int> {less + 1, more};
}

void quickSort(vector<int> &arr, int L, int R){
  if (L < R) {
    //swap(arr[L+(int)(random()*(R - L + 1))], arr[R]);//快排3.0
    vector<int> p = partition(arr, L, R);
    quickSort(arr, L, p[0] - 1);
    quickSort(arr, p[1] + 1, R);
  }
}
```

## 2.归并排序



