# 基础算法

## 1.快速排序

- #### 算法思想：`分治法`

##### 写法一：

```c++
void quickSort(vector<int> &arr, int L, int R){
  //base case
  if (L >= R) return;//只有一个数,边界检测，很重要
  //定义左右边界
  int less = L - 1, more = R + 1;
  //定义比较的标准，取中间的数作为比较标准
  int target = arr[L+(R - L >> 1)];
  //遍历数组，把小于target的数放左边，大于target的数放右边
  while (less < more) {
    do ++less; while(arr[less] < target);//从左往右找到第一个大于等于target的数的下标
    do --more; while(arr[more] > target);//从右往左找到第一个小于等于target的数的下标
    if (less < more) swap(arr[less], arr[more]);
    //什么时候不满足条件？-->当找到了target在数组中的正确位置，此时less > more
  }
  //递归去，分别快排左边和右边子数组
  quickSort(arr, L, more);
  quickSort(arr, more+1, R);
}
```

##### 写法二：

```c++
vector<int> partition(vector<int> &arr, int L, int R){
  int less = L - 1, more = R;
  //less表示最后一个小于arr[R]的下标,more表示第一个大于arr[R]的下标
  while (L < more) {
    if (arr[L] < arr[R]) {
      swap(arr[++less], arr[L++]);
    }else if (arr[L] > arr[R]) {
      swap(arr[--more], arr[L]);
    }else {
      L++;
    }
  }
  swap(arr[more], arr[R]);
  return vector<int> {less + 1, more};
}

void quickSort(vector<int> &arr, int L, int R){
  if (L < R) {
    //swap(arr[L+(int)(random()*(R - L + 1))], arr[R]);//快排3.0
    vector<int> p = partition(arr, L, R);
    quickSort(arr, L, p[0] - 1);
    quickSort(arr, p[1] + 1, R);
  }
}
```

## 2.归并排序

- #### 算法思想：`分治法`

  ##### 写法一：

  ```c++
  const int N = 1000010;
  void mergeSort(vector<int> &arr, int L, int R){
    //递归出口
    if (L >= R) return;
    //找分界点，划分大问题
    int mid = (L + R) >> 1;
    //划分子问题，“分”-递归调用
    mergeSort(arr, L, mid);
    mergeSort(arr, mid + 1, R);
    //合并子问题
    //思路：谁小就复制谁
    int k = 0, i = L, j = mid + 1;
    vector<int> tmp(N, 0);
    while (i <= mid && j <= R) {
      if (arr[i] <= arr[j]) tmp[k++] = arr[i++];
      else tmp[k++] = arr[j++];
    }
    //剩余的情况
    while (i <= mid) tmp[k++] = arr[i++];
    while (j <= R) tmp[k++] = arr[j++];
    //拷贝回原来的数组
    for (int i = L, j = 0; i <= R; i++, j++) arr[i++] = tmp[j++];    
  }
  ```

  ##### 写法二：

  ```c++
  void mergeSort(vector<int> &arr){
    //边界
    if (arr.size() < 2) return;
    else mergeSort(arr, 0, arr.size() - 1);
  }
  
  void mergeSort(vector<int> &arr, int L, int R){
    if (L == R) return;
    else {
      //分界点
      int mid = L + (R - L) >> 1;
      mergeSort(arr, L, mid);
      mergeSort(arr, mid + 1, R);
      //合并
      merge(arr, L, mid, R);
    }
  }
  
  void merge(vector<int> &arr, int L, int M, int R){
    //int* help = new int[R - L + 1];
    vector<int> help(R - L + 1, 0);
    int i = 0, p1 = L, p2 = M + 1;
    while (p1 <= M && p2 <= R) {
      help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++]; 
    }
    //剩余情况
    while (p1 <= M) help[i++] = arr[p1++];
    while (p2 <= R) help[i++] = arr[p2++];
    //拷贝回原来的数组
    for (int i = 0; i < help.size(); i++)  arr[L+i] = help[i];
    //delete [] help;
  }
  ```

## 3.二分法

- #### 算法思想：`二分的本质是二段性不是单调性`（并不是只有满足了单调性才能使用二分法，只要能通过某种标准将区域一分为二就可以使用二分法）

  ###### 例题：给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。如果数组中不存在该元素，则返回“-1 -1”。

  ###### 输入格式：第一行包含整数n和q，表示数组长度和询问个数。第二行包含n个整数（均在1~10000范围内），表示完整数组。接下来q行，每行包含一个整数k，表示一个询问元素。

  ###### 	如果数组中不存在该元素，则返回“-1 -1”。

  ###### 	数据范围

  ###### 	1≤n≤100000

  ###### 	1≤q≤10000

  ###### 	1≤k≤10000

  ```markdown
  输入:
  6 3
  1 2 2 3 3 4
  3
  4
  5
  
  输出:
  3 4
  5 5
  -1 -1
  ```

  ###### 题解：

  ```c++
  #include <iostream>
  #include <vector>
  
  using namespace std;
  
  int main(){
    int n, q;
    cin>>n>>q;
    
    vector<int> arr(n, 0);
    for (int i = 0; i < n; i++) cin>>arr[i];
    
    while (q--){
      int x;
      cin>>x;
      
      int l = 0, r = n - 1;
      while (l < r) {//找（左边界）第一个大于等于x的数
        int mid = (l + r) >> 1;
        if (x <= arr[mid]) r = mid;
        else l = mid + 1;
      }
      if (arr[l] != x) cout << "-1 -1" << endl;
      else {
        cout<<l<<" ";
        int l = 0, r = n - 1;
        while (l < r) {//找（右边界）第一个小于等于x的数
          int mid = (l + r + 1) >> 1;//??为啥要加一
          if (x >= arr[mid]) l = mid;
          else r = mid - 1;
        }
        cout<<l<<endl;
      }
    }
    return 0;
  }
  ```

- #### 边界问题：

  ##### 解释的比较好博客：

  ##### 1.[不需要考虑mid+1、mid-1的二分查找模板，希望大家都能学会](https://blog.csdn.net/WJPnb1/article/details/126360962?spm=1001.2014.3001.5502)

  ##### 2.[二分查找 & 二分答案 万字详解，超多例题，带你学透二分](https://blog.csdn.net/Mr_dimple/article/details/114656142?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-8-114656142-blog-126360962.pc_relevant_multi_platform_featuressortv2dupreplace&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-8-114656142-blog-126360962.pc_relevant_multi_platform_featuressortv2dupreplace&utm_relevant_index=9)

  ##### 内容
